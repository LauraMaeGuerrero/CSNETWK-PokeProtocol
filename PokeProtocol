import socket
import threading
import time
import random
import base64
import json
from enum import Enum
from typing import Dict, Any, Optional, Tuple
import os

class MessageType(Enum):
    HANDSHAKE_REQUEST = "HANDSHAKE_REQUEST"
    HANDSHAKE_RESPONSE = "HANDSHAKE_RESPONSE"
    SPECTATOR_REQUEST = "SPECTATOR_REQUEST"
    BATTLE_SETUP = "BATTLE_SETUP"
    ATTACK_ANNOUNCE = "ATTACK_ANNOUNCE"
    DEFENSE_ANNOUNCE = "DEFENSE_ANNOUNCE"
    CALCULATION_REPORT = "CALCULATION_REPORT"
    CALCULATION_CONFIRM = "CALCULATION_CONFIRM"
    RESOLUTION_REQUEST = "RESOLUTION_REQUEST"
    GAME_OVER = "GAME_OVER"
    CHAT_MESSAGE = "CHAT_MESSAGE"
    ACK = "ACK"

class PeerRole(Enum):
    HOST = "HOST"
    JOINER = "JOINER"
    SPECTATOR = "SPECTATOR"

class BattleState(Enum):
    SETUP = "SETUP"
    WAITING_FOR_MOVE = "WAITING_FOR_MOVE"
    PROCESSING_TURN = "PROCESSING_TURN"
    GAME_OVER = "GAME_OVER"

class PokeProtocol:
    def __init__(self, host: str = "0.0.0.0", port: int = 8888, verbose: bool = False):
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.settimeout(0.1)
        self.host = host
        self.port = port
        self.verbose = verbose
        
        # Protocol state
        self.role: Optional[PeerRole] = None
        self.opponent_address: Optional[Tuple[str, int]] = None
        self.spectators = []
        
        # Game state
        self.battle_state = BattleState.SETUP
        self.seed = None
        self.my_pokemon = None
        self.opponent_pokemon = None
        self.my_hp = 100
        self.opponent_hp = 100
        self.is_my_turn = False
        self.current_sequence = 0
        self.expected_sequence = 0
        
        # Reliability layer
        self.pending_acks = {}
        self.received_messages = set()
        
        # Stat boosts
        self.special_attack_uses = 5
        self.special_defense_uses = 5
        
        # Thread control
        self.running = False
        self.receive_thread = None
        
        # Connection tracking
        self.connected = False
        self.handshake_complete = False

    def log(self, message: str):
        if self.verbose:
            print(f"[DEBUG] {message}")

    def serialize_message(self, message_type: MessageType, **kwargs) -> str:
        lines = [f"message_type: {message_type.value}"]
        for key, value in kwargs.items():
            if value is not None:
                if isinstance(value, dict):
                    value = json.dumps(value)
                lines.append(f"{key}: {value}")
        return "\n".join(lines)

    def parse_message(self, data: str) -> Dict[str, Any]:
        message = {}
        for line in data.split("\n"):
            if ":" in line:
                key, value = line.split(":", 1)
                key = key.strip()
                value = value.strip()
                
                if key in ["stat_boosts", "pokemon"] and value.startswith("{"):
                    try:
                        value = json.loads(value)
                    except:
                        pass
                
                message[key] = value
        return message

    def send_message(self, message: str, address: Tuple[str, int], sequence_number: int = None):
        if sequence_number is None:
            sequence_number = self.current_sequence
            self.current_sequence += 1
            
        if "sequence_number" not in message:
            message_obj = self.parse_message(message)
            message_obj["sequence_number"] = sequence_number
            message = self.serialize_message(MessageType(message_obj["message_type"]), **{
                k: v for k, v in message_obj.items() if k != "message_type"
            })
        
        self.log(f"Sending to {address}: {message[:100]}...")
        try:
            self.socket.sendto(message.encode(), address)
        except Exception as e:
            print(f"Error sending message: {e}")
            return
            
        message_obj = self.parse_message(message)
        if message_obj["message_type"] != MessageType.ACK.value:
            self.pending_acks[sequence_number] = {
                "message": message,
                "address": address,
                "timestamp": time.time(),
                "retries": 0
            }

    def send_ack(self, sequence_number: int, address: Tuple[str, int]):
        ack_message = self.serialize_message(MessageType.ACK, ack_number=sequence_number)
        try:
            self.socket.sendto(ack_message.encode(), address)
        except Exception as e:
            print(f"Error sending ACK: {e}")

    def handle_message(self, data: str, address: Tuple[str, int]):
        try:
            message = self.parse_message(data)
            self.log(f"Received from {address}: {message}")
            
            message_type = message.get("message_type")
            sequence_number = int(message.get("sequence_number", -1))
            
            if message_type != MessageType.ACK.value:
                self.send_ack(sequence_number, address)
            
            if sequence_number in self.received_messages:
                return
                
            self.received_messages.add(sequence_number)
            
            handler_name = f"handle_{message_type.lower()}"
            if hasattr(self, handler_name):
                getattr(self, handler_name)(message, address)
            else:
                self.log(f"No handler for message type: {message_type}")
                
        except Exception as e:
            print(f"Error handling message: {e}")

    def handle_handshake_request(self, message: dict, address: Tuple[str, int]):
        if self.role == PeerRole.HOST and self.battle_state == BattleState.SETUP:
            print(f"Received connection request from {address}")
            self.opponent_address = address
            self.seed = random.randint(1, 1000000)
            random.seed(self.seed)
            
            response = self.serialize_message(
                MessageType.HANDSHAKE_RESPONSE,
                seed=self.seed
            )
            self.send_message(response, address)
            self.handshake_complete = True
            print(f"Sent handshake response to {address}")

    def handle_handshake_response(self, message: dict, address: Tuple[str, int]):
        if self.role == PeerRole.JOINER and self.battle_state == BattleState.SETUP:
            print(f"Received handshake response from {address}")
            self.opponent_address = address
            self.seed = int(message["seed"])
            random.seed(self.seed)
            self.handshake_complete = True
            print(f"Handshake completed with seed: {self.seed}")

    def handle_battle_setup(self, message: dict, address: Tuple[str, int]):
        if address == self.opponent_address:
            self.opponent_pokemon = message["pokemon_name"]
            self.connected = True
            
            if self.role == PeerRole.HOST:
                self.is_my_turn = True
                self.battle_state = BattleState.WAITING_FOR_MOVE
                print("\nBATTLE STARTED! You go first!")
            else:
                self.battle_state = BattleState.WAITING_FOR_MOVE
                print("\nBATTLE STARTED! Waiting for opponent's move...")

    def handle_attack_announce(self, message: dict, address: Tuple[str, int]):
        if self.battle_state == BattleState.WAITING_FOR_MOVE and not self.is_my_turn:
            move_name = message["move_name"]
            self.current_move = move_name
            print(f"\nOpponent used {move_name}!")
            
            defense_msg = self.serialize_message(MessageType.DEFENSE_ANNOUNCE)
            self.send_message(defense_msg, self.opponent_address)
            
            self.battle_state = BattleState.PROCESSING_TURN
            self.process_turn()

    def handle_defense_announce(self, message: dict, address: Tuple[str, int]):
        if self.battle_state == BattleState.WAITING_FOR_MOVE and self.is_my_turn:
            self.battle_state = BattleState.PROCESSING_TURN
            self.process_turn()

    def handle_calculation_report(self, message: dict, address: Tuple[str, int]):
        if self.battle_state == BattleState.PROCESSING_TURN:
            their_damage = int(message["damage_dealt"])
            their_defender_hp = int(message["defender_hp_remaining"])
            
            confirm_msg = self.serialize_message(MessageType.CALCULATION_CONFIRM)
            self.send_message(confirm_msg, self.opponent_address)
            
            if self.is_my_turn:
                self.opponent_hp = their_defender_hp
            else:
                self.my_hp = their_defender_hp
                
            print(f"Turn complete. Your HP: {self.my_hp}, Opponent HP: {self.opponent_hp}")
            
            if self.my_hp <= 0 or self.opponent_hp <= 0:
                self.handle_game_over()
            else:
                self.is_my_turn = not self.is_my_turn
                self.battle_state = BattleState.WAITING_FOR_MOVE

    def handle_calculation_confirm(self, message: dict, address: Tuple[str, int]):
        self.is_my_turn = not self.is_my_turn
        self.battle_state = BattleState.WAITING_FOR_MOVE

    def handle_chat_message(self, message: dict, address: Tuple[str, int]):
        sender = message.get("sender_name", "Unknown")
        content_type = message.get("content_type", "TEXT")
        
        if content_type == "TEXT":
            text = message.get("message_text", "")
            print(f"\nCHAT from {sender}: {text}")

    def handle_game_over(self, message: dict = None, address: Tuple[str, int] = None):
        if message:
            winner = message.get("winner")
            loser = message.get("loser")
            if self.my_pokemon == winner:
                print(f"\nVICTORY! You won the battle!")
            else:
                print(f"\nDEFEAT! You lost the battle!")
        else:
            if self.opponent_hp <= 0:
                winner = self.my_pokemon
                loser = self.opponent_pokemon
            else:
                winner = self.opponent_pokemon
                loser = self.my_pokemon
                
            game_over_msg = self.serialize_message(
                MessageType.GAME_OVER,
                winner=winner,
                loser=loser
            )
            self.send_message(game_over_msg, self.opponent_address)
            print(f"\nGAME OVER! {winner} defeated {loser}!")
        
        self.battle_state = BattleState.GAME_OVER

    def calculate_damage(self, move_name: str) -> dict:
        base_damage = random.randint(20, 40)
        damage = max(1, int(base_damage))
        
        if self.is_my_turn:
            new_opponent_hp = max(0, self.opponent_hp - damage)
            remaining_health = self.my_hp
        else:
            new_opponent_hp = self.opponent_hp
            remaining_health = max(0, self.my_hp - damage)
            
        return {
            "damage_dealt": damage,
            "defender_hp_remaining": new_opponent_hp if self.is_my_turn else remaining_health,
            "remaining_health": remaining_health if self.is_my_turn else self.my_hp
        }

    def process_turn(self):
        if not hasattr(self, 'current_move'):
            return
            
        result = self.calculate_damage(self.current_move)
        
        report_msg = self.serialize_message(
            MessageType.CALCULATION_REPORT,
            attacker=self.my_pokemon if self.is_my_turn else self.opponent_pokemon,
            move_used=self.current_move,
            remaining_health=result["remaining_health"],
            damage_dealt=result["damage_dealt"],
            defender_hp_remaining=result["defender_hp_remaining"],
            status_message=f"{self.my_pokemon if self.is_my_turn else self.opponent_pokemon} used {self.current_move}!"
        )
        self.send_message(report_msg, self.opponent_address)

    def start_host(self, pokemon_name: str = "Pikachu"):
        self.role = PeerRole.HOST
        self.my_pokemon = pokemon_name
        try:
            self.socket.bind((self.host, self.port))
            self.running = True
            print(f"Host started on {self.host}:{self.port}")
            print(f"Your Pokemon: {pokemon_name}")
            print("Waiting for opponent to connect...")
        except Exception as e:
            print(f"Error starting host: {e}")

    def start_joiner(self, host_ip: str, pokemon_name: str = "Charmander"):
        self.role = PeerRole.JOINER
        self.my_pokemon = pokemon_name
        self.opponent_address = (host_ip, self.port)
        self.running = True
        
        print(f"Connecting to {host_ip}:{self.port} as {pokemon_name}...")
        
        handshake_msg = self.serialize_message(MessageType.HANDSHAKE_REQUEST)
        self.send_message(handshake_msg, self.opponent_address)

    def send_attack(self, move_name: str):
        if self.battle_state == BattleState.WAITING_FOR_MOVE and self.is_my_turn:
            self.current_move = move_name
            attack_msg = self.serialize_message(
                MessageType.ATTACK_ANNOUNCE,
                move_name=move_name
            )
            self.send_message(attack_msg, self.opponent_address)
            print(f"You used {move_name}!")
            return True
        else:
            print("Not your turn or invalid battle state!")
            return False

    def send_chat_message(self, text: str):
        if self.opponent_address:
            chat_msg = self.serialize_message(
                MessageType.CHAT_MESSAGE,
                sender_name=self.my_pokemon,
                content_type="TEXT",
                message_text=text
            )
            self.send_message(chat_msg, self.opponent_address)
            print(f"You: {text}")
            return True
        return False

    def send_battle_setup(self):
        """Send battle setup after handshake is complete"""
        if self.handshake_complete and not self.connected:
            setup_msg = self.serialize_message(
                MessageType.BATTLE_SETUP,
                communication_mode="P2P",
                pokemon_name=self.my_pokemon,
                stat_boosts={
                    "special_attack_uses": self.special_attack_uses,
                    "special_defense_uses": self.special_defense_uses
                }
            )
            self.send_message(setup_msg, self.opponent_address)
            self.log("Sent battle setup")

    def retransmit_pending(self):
        current_time = time.time()
        messages_to_remove = []
        
        for seq, pending in self.pending_acks.items():
            if current_time - pending["timestamp"] > 0.5:
                if pending["retries"] < 3:
                    self.log(f"Retransmitting sequence {seq}")
                    self.socket.sendto(pending["message"].encode(), pending["address"])
                    pending["timestamp"] = current_time
                    pending["retries"] += 1
                else:
                    messages_to_remove.append(seq)
        
        for seq in messages_to_remove:
            del self.pending_acks[seq]

    def receive_loop(self):
        while self.running:
            try:
                data, addr = self.socket.recvfrom(1024)
                message = data.decode()
                
                message_obj = self.parse_message(message)
                if message_obj.get("message_type") == MessageType.ACK.value:
                    ack_num = int(message_obj.get("ack_number", -1))
                    if ack_num in self.pending_acks:
                        del self.pending_acks[ack_num]
                    continue
                
                self.handle_message(message, addr)
                
            except socket.timeout:
                self.retransmit_pending()
                
                # Send battle setup if handshake is complete but not connected
                if self.handshake_complete and not self.connected:
                    self.send_battle_setup()
                    
            except Exception as e:
                if self.running:
                    pass

    def start(self):
        if not self.running:
            self.running = True
            self.receive_thread = threading.Thread(target=self.receive_loop, daemon=True)
            self.receive_thread.start()
            self.log("Protocol started")

    def stop(self):
        self.running = False
        if self.receive_thread:
            self.receive_thread.join(timeout=1.0)
        self.socket.close()
        self.log("Protocol stopped")

def main():
    print("=== P2P Pokemon Battle Protocol ===")
    print("1. Start as Host")
    print("2. Join as Client")
    
    choice = input("Choose mode (1 or 2): ").strip()
    
    verbose = input("Enable verbose mode? (y/n): ").lower() == 'y'
    protocol = PokeProtocol(verbose=verbose)
    
    if choice == "1":
        pokemon = input("Enter your Pokemon name: ").strip() or "Pikachu"
        protocol.start_host(pokemon)
    else:
        host_ip = input("Enter host IP: ").strip() or "127.0.0.1"
        if ":" in host_ip:
            host_ip = host_ip.split(":")[0].strip()
        pokemon = input("Enter your Pokemon name: ").strip() or "Charmander"
        protocol.start_joiner(host_ip, pokemon)
    
    protocol.start()
    
    try:
        connection_attempts = 0
        max_attempts = 10
        
        while protocol.running and protocol.battle_state != BattleState.GAME_OVER:
            # Show connection status
            if not protocol.connected:
                if protocol.role == PeerRole.HOST:
                    print("Waiting for opponent to connect... (Press Ctrl+C to stop)", end='\r')
                else:
                    connection_attempts += 1
                    if connection_attempts > max_attempts:
                        print("\nConnection failed! Could not connect to host.")
                        break
                    print(f"Connecting to host... attempt {connection_attempts}/{max_attempts}", end='\r')
                time.sleep(1)
                continue
            
            # Show battle status when connected
            print(f"\n--- Battle Status ---")
            print(f"Your HP: {protocol.my_hp} | Opponent HP: {protocol.opponent_hp}")
            print(f"Special Attacks: {protocol.special_attack_uses} | Special Defenses: {protocol.special_defense_uses}")
            
            if protocol.battle_state == BattleState.WAITING_FOR_MOVE:
                if protocol.is_my_turn:
                    print("\nYour turn! Choose an action:")
                    print("1. Attack")
                    print("2. Send Chat Message")
                    print("3. Use Special Attack Boost")
                    print("4. Use Special Defense Boost")
                    print("5. Exit")
                    
                    action = input("Choose action (1-5): ").strip()
                    
                    if action == "1":
                        move = input("Enter move name: ").strip() or "Tackle"
                        protocol.send_attack(move)
                    elif action == "2":
                        message = input("Enter chat message: ").strip()
                        protocol.send_chat_message(message)
                    elif action == "3":
                        if protocol.special_attack_uses > 0:
                            print("Special attack boost activated for next attack!")
                        else:
                            print("No special attack boosts remaining!")
                    elif action == "4":
                        if protocol.special_defense_uses > 0:
                            print("Special defense boost activated for next defense!")
                        else:
                            print("No special defense boosts remaining!")
                    elif action == "5":
                        break
                    else:
                        print("Invalid action!")
                else:
                    print("Waiting for opponent's move...")
                    time.sleep(2)
            else:
                print("Processing turn...")
                time.sleep(2)
                
    except KeyboardInterrupt:
        print("\nShutting down...")
    finally:
        protocol.stop()

if __name__ == "__main__":
    main()
